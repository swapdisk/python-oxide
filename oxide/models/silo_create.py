# coding: utf-8

"""
    Oxide Region API

    API for interacting with the Oxide control plane

    The version of the OpenAPI document: 20240821.0
    Contact: api@oxide.computer
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from oxide.models.certificate_create import CertificateCreate
from oxide.models.fleet_role import FleetRole
from oxide.models.silo_identity_mode import SiloIdentityMode
from oxide.models.silo_quotas_create import SiloQuotasCreate
from typing import Optional, Set
from typing_extensions import Self

class SiloCreate(BaseModel):
    """
    Create-time parameters for a `Silo`
    """ # noqa: E501
    admin_group_name: Optional[StrictStr] = Field(default=None, description="If set, this group will be created during Silo creation and granted the \"Silo Admin\" role. Identity providers can assert that users belong to this group and those users can log in and further initialize the Silo.  Note that if configuring a SAML based identity provider, group_attribute_name must be set for users to be considered part of a group. See `SamlIdentityProviderCreate` for more information.")
    description: StrictStr
    discoverable: StrictBool
    identity_mode: SiloIdentityMode
    mapped_fleet_roles: Optional[Dict[str, List[FleetRole]]] = Field(default=None, description="Mapping of which Fleet roles are conferred by each Silo role  The default is that no Fleet roles are conferred by any Silo roles unless there's a corresponding entry in this map.")
    name: Annotated[str, Field(min_length=1, strict=True, max_length=63)] = Field(description="Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.")
    quotas: SiloQuotasCreate = Field(description="Limits the amount of provisionable CPU, memory, and storage in the Silo. CPU and memory are only consumed by running instances, while storage is consumed by any disk or snapshot. A value of 0 means that resource is *not* provisionable.")
    tls_certificates: List[CertificateCreate] = Field(description="Initial TLS certificates to be used for the new Silo's console and API endpoints.  These should be valid for the Silo's DNS name(s).")
    __properties: ClassVar[List[str]] = ["admin_group_name", "description", "discoverable", "identity_mode", "mapped_fleet_roles", "name", "quotas", "tls_certificates"]

    @field_validator('name')
    def name_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$", value):
            raise ValueError(r"must validate the regular expression /^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SiloCreate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of identity_mode
        if self.identity_mode:
            _dict['identity_mode'] = self.identity_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in mapped_fleet_roles (dict of array)
        _field_dict_of_array = {}
        if self.mapped_fleet_roles:
            for _key_mapped_fleet_roles in self.mapped_fleet_roles:
                if self.mapped_fleet_roles[_key_mapped_fleet_roles] is not None:
                    _field_dict_of_array[_key_mapped_fleet_roles] = [
                        _item.to_dict() for _item in self.mapped_fleet_roles[_key_mapped_fleet_roles]
                    ]
            _dict['mapped_fleet_roles'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of quotas
        if self.quotas:
            _dict['quotas'] = self.quotas.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tls_certificates (list)
        _items = []
        if self.tls_certificates:
            for _item_tls_certificates in self.tls_certificates:
                if _item_tls_certificates:
                    _items.append(_item_tls_certificates.to_dict())
            _dict['tls_certificates'] = _items
        # set to None if admin_group_name (nullable) is None
        # and model_fields_set contains the field
        if self.admin_group_name is None and "admin_group_name" in self.model_fields_set:
            _dict['admin_group_name'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SiloCreate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "admin_group_name": obj.get("admin_group_name"),
            "description": obj.get("description"),
            "discoverable": obj.get("discoverable"),
            "identity_mode": SiloIdentityMode.from_dict(obj["identity_mode"]) if obj.get("identity_mode") is not None else None,
            "mapped_fleet_roles": dict(
                (_k,
                        [FleetRole.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("mapped_fleet_roles", {}).items()
            ),
            "name": obj.get("name"),
            "quotas": SiloQuotasCreate.from_dict(obj["quotas"]) if obj.get("quotas") is not None else None,
            "tls_certificates": [CertificateCreate.from_dict(_item) for _item in obj["tls_certificates"]] if obj.get("tls_certificates") is not None else None
        })
        return _obj


